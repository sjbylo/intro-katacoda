The Source-To-Image (S2I) tool comes fully integrated with OpenShift.  S2I is especially useful for developers as it can shield them from the details of creating Docker images.  

Two of the main reasons to use S2I are:

1. Developers can get up and running with Linux containers without knowing much (if at all) about Docker itself.  This is great for Developers who just want to get their code running in a Linux container.
2. Enterprises need more control over how their teams build images and don't want to allow developers the freedom to install anything they choose (as root) into container images.  The S2I process constrains somewhat how the user builds images and does not allow anything to be installed during the S2I process using root privileges. 

So, for this scenario, imagine you are a Lead Developer or an Operations Lead and want to create a way for your developers (OpenShift users) to easily and securly create docker images containing their applications. 

# The simplified runtime

For this scenario we will avoid any complications with specific runtimes and/or languages and their build processes and use a very simple runtime.

The application "runtime" we will use is represented by the Linux command "cat" which simply displays the contents of files.

Our S2I Builder Image's runtime will contain the command "cat". To create an application image, the developer need only pass files ("source code") during the build process. 
The Builder container will know where to place the source code so that it can be later "executed" by the runtime "cat".

The S2I build process looks like this:

- add image #FIXME

# The S2I build process

The S2I Builder Image contains the scripts needed to first build the application and then to run the application.
The _assemble_ script knows how to build the application from source code and
the _run_ script knows how to execute the application.  

In the simplist case, the process of building the application image is as follows:

1. Instantiate the S2I Builder Image.
2. Copy the source code into the running container.
3. Execute the _assemble_ script to build the source code to create the application. 
4. Commit the container to create the new image.

# Running the application image

When the resulting application image is instantiated, the _run_ script executes the _cat_ command to display the contents of any "source code" stored inside the image. 

